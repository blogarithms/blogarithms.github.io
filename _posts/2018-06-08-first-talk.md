---
layout: post
title: "Giving My First Technical Talk -- On Algorithms!"
excerpt: "My experience giving a talk on algorithms and competitive programming, to CS undergrads from tier-3 colleges!"
categories: [speaking, personal]
image:
    feature: firsttalk.jpg
comments: true
---

During my software engineering internship at Cisco in the summer of 2018, I received a curious message on LinkedIn.

It read "We are helping top-skilled students from rural backgrounds, and we invite you to be a guest speaker for our event."

This was a first for me -- I mean, I was a teenager, and it was really scary to be asked to go up in front of everyone and give a talk.

This was unlike anything I'd done before. 

**This was a technical talk.**

I had to gauge the technical ability of my audience and orient myself accordingly.

And that imposter syndrome was also kicking in with a part of me wondering -

> Hey, what if every one of them knows more than you? What if you just end up wasting everyone's time?

My parents and colleagues at Cisco reassured me that this wouldn't be the case because I wouldn't have been invited otherwise.

With that in mind, I accepted the invitation as a guest speaker. Plus, how'd I grow if I didn't leave my comfort zone, right?

#### tl:dr; It was awesome!

As it turns out, I was able to add value to every single member of the audience.

The event was really cool, because it wasn't a formal class-lecture style scenario.

There were other guest speakers who visited the event, all were engineers/developers from some really cool places (think Directi, Adobe, Uber, Intel etc) and it felt really cool to be placed in the same category as them. :p 

The way the talks worked, was that the audience would be split into groups of 15-20 and then would be paired with a speaker. Over the day, the groups would rotate getting to listen to every speaker's content, and consequently the speakers would interact with multiple groups as well.

I got to interact with about 6 groups overall! :)

## What I Talked About

I dove deep with the audience into algorithm design. To gauge the technical level of my audience, I made the sessions very interactive, asking questions back-and-forth and paying attention to the answers I was getting to understand how deep or fast I can go.

The next challenge was to find a topic to talk about. Algorithms is a super broad subject.

From graphs, to strings, to data structures, to optimization techniques, to bitwise operations -- then greedy, dynamic programming, backtracking -- so many problem-solving paradigms!

So I picked dynamic programming. Because it's so simple to begin with, and yet can grow increasingly to mind-bending levels.

Looking back, it was a great choice.

I started with the definition of recursion, how it can be applied in solving simple problems, how to identify and prove relations and equations using recursion.

For example, one of my questions to judge the technical ability of my audience, was asking them for a mathematical recursive proof on showing how a set of `N` elements can generate `(2^N) - 1` non-empty subsets.

After giving the audience a few minutes of thinking time, I'd work out the math on the whiteboard and show them how recursion can be leveraged.

Then I went onto explaining the cliche DP approach on the fibonacci series.

Then I made things interesting.

I started to ask questions and gave the audience time to brainstorm as a team, after which I discussed multiple solutions with the audience and explained why some are better than the others.

Over the day, I covered many classical variants of DP (both, top-down and bottom-up) -
- Prefix Sums and Suffix Sums
- 0-1 Knapsack
- Coin Change
- Longest Increasing Subsequence
- Longest Common Substring
- Longest Common Subsequence
- Shortest Path On A Grid
- Linear Dynamic Programming Recurrences
- Sliding Window
- Subset Sum

And it was way more fun than I thought it'd be -- because something happened which I didn't realize might -- when someone in the audience told me of a solution they had to one of my questions, and when that solution didn't match what I was expecting, I'd have to prove whether it would be right or not **on the spot!**

And that kind of quick on-the-spot thinking was super fun to do, because then it'd become a sort of volley back-and-forth between me and the audience trying to prove or disprove statements.

It was super fun overall, and the experience left me with the desire to give more talks in general, and the motivation to achieve more to get invited more. :)

